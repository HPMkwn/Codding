{
    "header snippet": {
        "prefix": "!",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "#define rep(a, b, i) for (int i = a; i < b; i++)",
            "#define rrep(a, b, i) for (int i = a; i >= b; i--)",
            "#define m 1000000007",
            "",
            "int main(){",
            "",
            "    return 0;",
            "}"
        ],
        "description": "header snippet"
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "int n,e,x,y;",
            "cin>>n>>e;",
            "vector<vector<int>> graph(n);",
            "F(0,e,i){",
            "    cin>>x>>y;",
            "    graph[x-1].push_back(y-1);",
            "    graph[y-1].push_back(x-1);",
            "}",
            "vector<bool> visited(n,false);"
        ],
        "description": "graph"
    },
    "wgraph": {
        "prefix": "wgraph",
        "body": [
            "int n, e, x, y, w;",
            "cin >> n >> e;",
            "vector<vector<pair<int, int>>> graph(n);",
            "F(0, e, i){",
            "   cin >> x >> y >> w;",
            "   graph[x - 1].push_back({y - 1, w});",
            "   graph[y - 1].push_back({x - 1, w});",
            "}",
            "vector<bool> visited(n, false);"
        ],
        "description": "wgraph"
    },
    "dfs": {
        "prefix": "dfs",
        "body": [
            "void dfs(vector<vector<int>>& graph,int sv,vector<bool>& visited){",
            "    visited[sv] = true;",
            "    cout<<sv<<\" \";",
            "    for(int cv : graph[sv]){",
            "        if(!visited[cv])",
            "            dfs(graph,cv,visited);",
            "    }",
            "}"
        ],
        "description": "dfs"
    },

    "bfs": {
        "prefix": "bfs",
        "body": [
            "void bfs(vector<vector<int>> &graph, int sv, vector<bool>visited)",
            "{",
            "    queue<int> q;",
            "    q.push(sv);",
            "    visited[sv] = true;",
            "",
            "    while (!q.empty()){",
            "        sv = q.front();",
            "        cout << sv << \" \";",
            "        q.pop();",
            "        for (int cv : graph[sv]){",
            "            if (!visited[cv]){",
            "                visited[cv] = true;",
            "                q.push(cv);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "bfs"
    },
    "vector-print": {
        "prefix": "vp",
        "body": [
            "template<typename T>",
            "void vp(T a){",
            "    for(int i=0;i<a.size();i++){",
            "        cout<<a[i]<<\" \";",
            "    }",
            "    cout<<\"\\n\";",
            "}"
        ],
        "description": "print vector only"
    },
    "dijstra": {
        "prefix": "dijstra",
        "body": [
            "int dijkstra(vector<vector<pair<int, int>>> &graph, vector<bool> visited, int sv, int ev)",
            "{",
            "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "    vector<int> dist(graph.size(), INT_MAX);",
            "    vector<int> p(graph.size(),-1);",
            "    dist[sv] = 0;",
            "    p[sv]=sv;",
            "    q.push({0, sv});",
            "    pair<int, int> ele;",
            "    while (!q.empty())",
            "    {",
            "        ele = q.top();",
            "        q.pop();",
            "        for (auto cv : graph[ele.second])",
            "        {",
            "            if (dist[ele.second] + cv.second < dist[cv.first])",
            "            {",
            "                dist[cv.first] = dist[ele.second] + cv.second;",
            "                q.push({dist[cv.first], cv.first});",
            "                p[cv.first] = ele.second;",
            "            }",
            "        }",
            "    }",
            "    return dist[ev];",
            "}"
        ],
        "description": "dijstra"
    },
    "prims": {
        "prefix": "prims",
        "body": [
            "vector<int> prims(vector<vector<pair<int, int>>> &graph, vector<bool> visited, int sv)",
            "{",
            "    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;",
            "    vector<int> dist(graph.size(), INT_MAX);",
            "    vector<int> p(graph.size(),-1);",
            "    dist[sv] = 0;",
            "    q.push({0, sv});",
            "    pair<int, int> ele;",
            "    while (!q.empty())",
            "    {   ",
            "        ele = q.top();",
            "        visited[ele.second]=true;",
            "        q.pop();",
            "        for (auto cv : graph[ele.second])",
            "        {",
            "            if (!visited[cv.first] && cv.second < dist[cv.first])",
            "            {",
            "                dist[cv.first] = cv.second;",
            "                q.push({dist[cv.first], cv.first});",
            "                p[cv.first] = ele.second;",
            "            }",
            "        }",
            "    }",
            "    return p;",
            "}"
        ],
        "description": "prims"
    },
    "kruskal": {
        "prefix": "kruskal",
        "body": [
            "template<typename T>",
            "void vp(T a){",
            "    cout<<\"\\n\";",
            "    for(int i=0;i<a.size();i++){",
            "        cout<<a[i].s<<\" \"<<a[i].d << \" \"<<a[i].w<<\"\\n\";",
            "    }",
            "}",
            "struct edge",
            "{",
            "    int s,d,w;",
            "    edge() : s(0),d(0),w(0){};",
            "};",
            "",
            "bool check(edge a,edge b){",
            "    if(a.w != b.w)return a.w< b.w;",
            "    else if (a.d!= b.d) return a.d < b.d;",
            "    else a.s<b.s;",
            "}",
            "",
            "int find(vector<int> parent, int point)",
            "{",
            "    while (parent[point] != point)",
            "        point = parent[point];",
            "",
            "    return point;",
            "}",
            "",
            "vector<edge> kruskal(vector<edge> edges ,vector<bool> visited,int e,int sv){",
            "    ",
            "    sort(edges.begin(),edges.end(),check);",
            "    ",
            "    vector<edge> mst;",
            "    vector<int> parent(e+1,-1);",
            "    F(0,e+1,i)parent[i]=i;",
            "    int count=0,i=0;",
            "    while (count < e)",
            "    {",
            "        int ps = find(parent,edges[i].s);",
            "        int pd = find(parent,edges[i].d);",
            "",
            "        if(ps!= pd){",
            "            mst.push_back(edges[i]);",
            "            count++;",
            "            parent[pd] = ps;",
            "        }",
            "        i++;",
            "    }",
            "    return mst;",
            "}",
            "",
            "int main(){",
            "    int n, e, x, y, w;",
            "    cin >> n >> e;",
            "    vector<edge> edges(e);",
            "    F(0, e, i){",
            "       cin >> edges[i].s >> edges[i].d >> edges[i].w;",
            "    }",
            "    vector<bool> visited(n, false);",
            "    vector<edge> mst = kruskal(edges,visited,n-1,0);",
            "    vp(mst);",
            "    return 0;",
            "}"
        ],
        "description": "kruskal"
    },
    "restore_path": {
        "prefix": "restore_path",
        "body": [
            "vector<int> restore_path(vector<int>& p,int sv,int ev){",
            "",
            "    vector<int> path;",
            "    for (int i = ev; i != sv; i = p[i]) ",
            "    {",
            "        path.push_back(i);",
            "    }",
            "    path.push_back(sv);",
            "    reverse(path.begin(),path.end());",
            "    return path;",
            "    ",
            "}"
        ],
        "description": "restore_path"
    }
}